<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/goblenstudios/thrainer/StudyRoom/StudyRoomActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/goblenstudios/thrainer/StudyRoom/StudyRoomActivity.kt" />
              <option name="originalContent" value="package com.goblenstudios.thrainer.StudyRoom&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.ClipData&#10;import android.content.ClipDescription&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.DragEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.FrameLayout&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.goblenstudios.thrainer.CommunityActivity&#10;import com.goblenstudios.thrainer.CreateCardActivity&#10;import com.goblenstudios.thrainer.CreateDeckDialogFragment&#10;import com.goblenstudios.thrainer.DeckScreenActivity&#10;import com.goblenstudios.thrainer.FlashcardActivity&#10;import com.goblenstudios.thrainer.HomeActivity&#10;import com.goblenstudios.thrainer.R&#10;import com.goblenstudios.thrainer.repositories.DeckRepository&#10;import com.goblenstudios.thrainer.dtos.ReturnDeckDto&#10;import com.goblenstudios.thrainer.services.RetrofitInstance&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import com.bumptech.glide.Glide&#10;import com.goblenstudios.thrainer.repositories.UserCardRepository&#10;&#10;class StudyRoomActivity : AppCompatActivity() {&#10;    // Função utilitária para converter dp em px&#10;    fun dp(value: Int): Int = (value * resources.displayMetrics.density).toInt()&#10;&#10;    private var selectedDeckId: Long? = null&#10;    private val deckRepository = DeckRepository(RetrofitInstance.deckService)&#10;&#10;    private val userCardRepository = UserCardRepository(RetrofitInstance.userCardService)&#10;&#10;    @SuppressLint(&quot;ClickableViewAccessibility&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_study_room)&#10;        overridePendingTransition(R.drawable.fade_in, R.drawable.fade_out)&#10;&#10;        // Carregar GIF animado no background&#10;        val backgroundImage = findViewById&lt;ImageView&gt;(R.id.backgroundImage)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.study_room_animated)&#10;            .into(backgroundImage)&#10;&#10;        val tvDeckName = findViewById&lt;TextView&gt;(R.id.tvDeckName)&#10;        val llTop =&#10;            findViewById&lt;LinearLayout&gt;(R.id.llTop)  // De onde o objeto view pode ser arrastado&#10;        val llCauldron =&#10;            findViewById&lt;LinearLayout&gt;(R.id.llCauldron)  // Destino onde o objeto view pode ser solto&#10;//        val itens = listOf(&quot;Arrasta 1&quot;, &quot;Arrasta 2&quot;, &quot;Arrasta 3&quot;, &quot;Arrasta 4&quot;, &quot;Arrasta 5&quot;)&#10;        val dragListener = View.OnDragListener { view, event -&gt;&#10;            when (event.action) {&#10;                DragEvent.ACTION_DRAG_STARTED -&gt; event.clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)&#10;                DragEvent.ACTION_DRAG_ENTERED -&gt; {&#10;                    view.invalidate(); true&#10;                }&#10;&#10;                DragEvent.ACTION_DRAG_LOCATION -&gt; true&#10;                DragEvent.ACTION_DRAG_EXITED -&gt; {&#10;                    view.invalidate(); true&#10;                }&#10;&#10;                DragEvent.ACTION_DROP -&gt; {&#10;                    val item = event.clipData.getItemAt(0)&#10;                    val dragData = item.text&#10;                    tvDeckName.text = dragData&#10;                    Toast.makeText(this, dragData, Toast.LENGTH_SHORT).show()&#10;                    view.invalidate()&#10;                    val v = event.localState as View&#10;                    val owner = v.parent as ViewGroup&#10;                    owner.removeView(v)&#10;&#10;                    // Guardar o id do deck selecionado ao dropar no caldeirão&#10;                    if (view.id == R.id.llCauldron) {&#10;                        selectedDeckId = v.tag as? Long&#10;                    }&#10;&#10;                    when (view.id) {&#10;                        R.id.llCauldron -&gt; {&#10;                            // Animação de retorno&#10;                            v.animate()&#10;                                .translationX(0f)&#10;                                .translationY(0f)&#10;                                .setDuration(300)&#10;                                .withEndAction {&#10;                                    llTop.addView(v)&#10;                                    v.visibility = View.VISIBLE&#10;                                }&#10;                                .start()&#10;                        }&#10;&#10;                        R.id.llTop -&gt; {&#10;                            // Não faz nada, impede reorder&#10;                            owner.addView(v) // Retorna para o local original&#10;                            v.visibility = View.VISIBLE&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            val destination = view as LinearLayout&#10;                            destination.addView(v)&#10;                            v.visibility = View.VISIBLE&#10;                        }&#10;                    }&#10;                    true&#10;                }&#10;&#10;                DragEvent.ACTION_DRAG_ENDED -&gt; {&#10;                    view.invalidate()&#10;                    val draggedView = event.localState as? View&#10;                    draggedView?.visibility = View.VISIBLE&#10;                    true&#10;                }&#10;&#10;                else -&gt; false&#10;            }&#10;        }&#10;&#10;        llTop.setOnDragListener(dragListener)&#10;        llCauldron.setOnDragListener(dragListener)&#10;&#10;        // Buscar decks reais do usuário nas SharedPreferences&#10;        val prefs = getSharedPreferences(&quot;user_prefs&quot;, MODE_PRIVATE)&#10;        val userId = prefs.getLong(&quot;user_id&quot;, -1L)&#10;        if (userId == -1L) {&#10;            Toast.makeText(this, &quot;Usuário não encontrado.&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Buscar decks do usuário de forma assíncrona&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            val result = withContext(Dispatchers.IO) { deckRepository.getDecksByUser(userId) }&#10;            if (result.isSuccess) {&#10;                val decks: List&lt;ReturnDeckDto&gt; = result.getOrNull() ?: emptyList&lt;ReturnDeckDto&gt;()&#10;                val deckMap = decks.associateBy { it.name } // Mapear nome para id&#10;                if (decks.isEmpty()) {&#10;                    // Exibe mensagem se não houver decks&#10;                    val emptyText = TextView(this@StudyRoomActivity).apply {&#10;                        text = &quot;Nenhum deck encontrado.&quot;&#10;                        setTextColor(resources.getColor(android.R.color.white, null))&#10;                        textSize = 16f&#10;                        gravity = android.view.Gravity.CENTER&#10;                    }&#10;                    llTop.addView(emptyText)&#10;                } else {&#10;                    // Para cada deck, cria um bloco arrastável&#10;                    for ((index, deck) in decks.withIndex()) {&#10;                        val frameLayout = FrameLayout(this@StudyRoomActivity).apply {&#10;                            layoutParams = LinearLayout.LayoutParams(dp(180), dp(60)).apply {&#10;                                marginEnd = dp(8)&#10;                                topMargin = dp(6)&#10;                            }&#10;                            // Imagem de fundo do bloco&#10;                            setBackgroundResource(R.drawable.sample2)&#10;                        }&#10;                        val textView = TextView(this@StudyRoomActivity).apply {&#10;                            layoutParams = FrameLayout.LayoutParams(&#10;                                FrameLayout.LayoutParams.MATCH_PARENT,&#10;                                FrameLayout.LayoutParams.MATCH_PARENT&#10;                            )&#10;                            text = deck.name&#10;                            setTextColor(resources.getColor(android.R.color.black, null))&#10;                            gravity = android.view.Gravity.CENTER&#10;                        }&#10;                        frameLayout.addView(textView)&#10;                        // Evento de toque longo para iniciar o arraste do deck&#10;                        frameLayout.setOnLongClickListener { v -&gt;&#10;                            val item = ClipData.Item(deck.name)&#10;                            val dragData = ClipData(&#10;                                deck.name,&#10;                                arrayOf(ClipDescription.MIMETYPE_TEXT_PLAIN),&#10;                                item&#10;                            )&#10;                            val shadow = View.DragShadowBuilder(v)&#10;                            v.visibility = View.INVISIBLE&#10;                            v.startDragAndDrop(dragData, shadow, v, 0)&#10;                            true&#10;                        }&#10;                        // Evento de clique simples para abrir a tela do deck&#10;                        frameLayout.setOnClickListener {&#10;                            val intent =&#10;                                Intent(this@StudyRoomActivity, DeckScreenActivity::class.java)&#10;                            intent.putExtra(&quot;deckId&quot;, deck.idDeck)&#10;                            intent.putExtra(&quot;deckName&quot;, deck.name)&#10;                            startActivity(intent)&#10;                            overridePendingTransition(0, 0)&#10;                        }&#10;                        // Guardar o id do deck no tag do frameLayout para uso no drop&#10;                        frameLayout.tag = deck.idDeck&#10;                        llTop.addView(frameLayout)&#10;                    }&#10;                }&#10;            } else {&#10;                // Exibe mensagem de erro se falhar ao buscar decks&#10;                val errorText = TextView(this@StudyRoomActivity).apply {&#10;                    text = &quot;Erro ao carregar decks.&quot;&#10;                    setTextColor(resources.getColor(android.R.color.white, null))&#10;                    textSize = 16f&#10;                    gravity = android.view.Gravity.CENTER&#10;                }&#10;                llTop.addView(errorText)&#10;            }&#10;&#10;&#10;            // Botões e overlays&#10;            val btnReturnToHome = findViewById&lt;Button&gt;(R.id.btnReturnToHome)&#10;            val btnLeftCenter = findViewById&lt;ImageButton&gt;(R.id.btnLeftCenter)&#10;            val btnRightCenter = findViewById&lt;Button&gt;(R.id.btnRightCenter)&#10;            val leftOverlay = findViewById&lt;FrameLayout&gt;(R.id.leftOverlay)&#10;            val btnCloseOverlay = findViewById&lt;ImageButton&gt;(R.id.btnCloseOverlay)&#10;&#10;&#10;            // Eventos de clique dos botões&#10;            btnLeftCenter.setOnClickListener {&#10;                leftOverlay.visibility = View.VISIBLE&#10;                btnReturnToHome.visibility = View.INVISIBLE&#10;                btnLeftCenter.visibility = View.INVISIBLE&#10;            }&#10;&#10;            btnRightCenter.setOnClickListener {&#10;                val intent = Intent(this@StudyRoomActivity, FlashcardActivity::class.java)&#10;                if (selectedDeckId == null) {&#10;                    Toast.makeText(&#10;                        this@StudyRoomActivity,&#10;                        &quot;Por favor, arraste um deck para o caldeirão antes de começar a estudar!&quot;,&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    try {&#10;                        val result = withContext(Dispatchers.IO) {&#10;                            userCardRepository.practiceCardsByDeck(userId, selectedDeckId!!)&#10;                        }&#10;&#10;                        if (result.isSuccess) {&#10;                            val cards = result.getOrNull().orEmpty()&#10;                            if (cards.isEmpty()) {&#10;                                Toast.makeText(&#10;                                    this@StudyRoomActivity,&#10;                                    &quot;Deck selecionado não possui cards.&quot;,&#10;                                    Toast.LENGTH_LONG&#10;                                ).show()&#10;                                return@launch&#10;                            }&#10;&#10;                        } else {&#10;                            Toast.makeText(&#10;                                this@StudyRoomActivity,&#10;                                &quot;Erro ao verificar cards do deck.&quot;,&#10;                                Toast.LENGTH_LONG&#10;                            ).show()&#10;                        }&#10;&#10;&#10;                    } catch (e: Exception) {&#10;                        Toast.makeText(&#10;                            this@StudyRoomActivity,&#10;                            &quot;Erro de conexão: ${e.message}&quot;,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;&#10;&#10;&#10;                intent.putExtra(&quot;deckId&quot;, selectedDeckId)&#10;                startActivity(intent)&#10;//                overridePendingTransition(0, 0)&#10;//                finish()&#10;            }&#10;&#10;            btnCloseOverlay.setOnClickListener {&#10;                leftOverlay.visibility = View.GONE&#10;                btnReturnToHome.visibility = View.VISIBLE&#10;                btnLeftCenter.visibility = View.VISIBLE&#10;            }&#10;&#10;            btnReturnToHome.setOnClickListener {&#10;                startActivity(Intent(this@StudyRoomActivity, HomeActivity::class.java)) // Inicia a MainActivity&#10;                overridePendingTransition(0, 0)&#10;                finish() // Finaliza a atividade atual e retorna para a anterior (MainActivity)&#10;            }&#10;&#10;            // Botão de teste para abrir CreateDeckActivity&#10;            val btnOpenCreateDeck = findViewById&lt;Button&gt;(R.id.btnOpenCreateDeck)&#10;            btnOpenCreateDeck.setOnClickListener {&#10;                CreateDeckDialogFragment().show(supportFragmentManager, &quot;CreateDeckDialog&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.goblenstudios.thrainer.StudyRoom&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.ClipData&#10;import android.content.ClipDescription&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.DragEvent&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.FrameLayout&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.goblenstudios.thrainer.CommunityActivity&#10;import com.goblenstudios.thrainer.CreateCardActivity&#10;import com.goblenstudios.thrainer.CreateDeckDialogFragment&#10;import com.goblenstudios.thrainer.DeckScreenActivity&#10;import com.goblenstudios.thrainer.FlashcardActivity&#10;import com.goblenstudios.thrainer.HomeActivity&#10;import com.goblenstudios.thrainer.R&#10;import com.goblenstudios.thrainer.repositories.DeckRepository&#10;import com.goblenstudios.thrainer.dtos.ReturnDeckDto&#10;import com.goblenstudios.thrainer.services.RetrofitInstance&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import com.bumptech.glide.Glide&#10;import com.goblenstudios.thrainer.repositories.UserCardRepository&#10;&#10;class StudyRoomActivity : AppCompatActivity() {&#10;    // Função utilitária para converter dp em px&#10;    fun dp(value: Int): Int = (value * resources.displayMetrics.density).toInt()&#10;&#10;    private var selectedDeckId: Long? = null&#10;    private val deckRepository = DeckRepository(RetrofitInstance.deckService)&#10;&#10;    private val userCardRepository = UserCardRepository(RetrofitInstance.userCardService)&#10;&#10;    @SuppressLint(&quot;ClickableViewAccessibility&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_study_room)&#10;        overridePendingTransition(R.drawable.fade_in, R.drawable.fade_out)&#10;&#10;        // Carregar GIF animado no background&#10;        val backgroundImage = findViewById&lt;ImageView&gt;(R.id.backgroundImage)&#10;        Glide.with(this)&#10;            .asGif()&#10;            .load(R.drawable.study_room_animated)&#10;            .into(backgroundImage)&#10;&#10;        val tvDeckName = findViewById&lt;TextView&gt;(R.id.tvDeckName)&#10;        val llTop =&#10;            findViewById&lt;LinearLayout&gt;(R.id.llTop)  // De onde o objeto view pode ser arrastado&#10;        val llCauldron =&#10;            findViewById&lt;LinearLayout&gt;(R.id.llCauldron)  // Destino onde o objeto view pode ser solto&#10;//        val itens = listOf(&quot;Arrasta 1&quot;, &quot;Arrasta 2&quot;, &quot;Arrasta 3&quot;, &quot;Arrasta 4&quot;, &quot;Arrasta 5&quot;)&#10;        val dragListener = View.OnDragListener { view, event -&gt;&#10;            when (event.action) {&#10;                DragEvent.ACTION_DRAG_STARTED -&gt; event.clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)&#10;                DragEvent.ACTION_DRAG_ENTERED -&gt; {&#10;                    view.invalidate(); true&#10;                }&#10;&#10;                DragEvent.ACTION_DRAG_LOCATION -&gt; true&#10;                DragEvent.ACTION_DRAG_EXITED -&gt; {&#10;                    view.invalidate(); true&#10;                }&#10;&#10;                DragEvent.ACTION_DROP -&gt; {&#10;                    val item = event.clipData.getItemAt(0)&#10;                    val dragData = item.text&#10;                    tvDeckName.text = dragData&#10;                    Toast.makeText(this, dragData, Toast.LENGTH_SHORT).show()&#10;                    view.invalidate()&#10;                    val v = event.localState as View&#10;                    val owner = v.parent as ViewGroup&#10;                    owner.removeView(v)&#10;&#10;                    // Guardar o id do deck selecionado ao dropar no caldeirão&#10;                    if (view.id == R.id.llCauldron) {&#10;                        selectedDeckId = v.tag as? Long&#10;                    }&#10;&#10;                    when (view.id) {&#10;                        R.id.llCauldron -&gt; {&#10;                            // Animação de retorno&#10;                            v.animate()&#10;                                .translationX(0f)&#10;                                .translationY(0f)&#10;                                .setDuration(300)&#10;                                .withEndAction {&#10;                                    llTop.addView(v)&#10;                                    v.visibility = View.VISIBLE&#10;                                }&#10;                                .start()&#10;                        }&#10;&#10;                        R.id.llTop -&gt; {&#10;                            // Não faz nada, impede reorder&#10;                            owner.addView(v) // Retorna para o local original&#10;                            v.visibility = View.VISIBLE&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            val destination = view as LinearLayout&#10;                            destination.addView(v)&#10;                            v.visibility = View.VISIBLE&#10;                        }&#10;                    }&#10;                    true&#10;                }&#10;&#10;                DragEvent.ACTION_DRAG_ENDED -&gt; {&#10;                    view.invalidate()&#10;                    val draggedView = event.localState as? View&#10;                    draggedView?.visibility = View.VISIBLE&#10;                    true&#10;                }&#10;&#10;                else -&gt; false&#10;            }&#10;        }&#10;&#10;        llTop.setOnDragListener(dragListener)&#10;        llCauldron.setOnDragListener(dragListener)&#10;&#10;        // Buscar decks reais do usuário nas SharedPreferences&#10;        val prefs = getSharedPreferences(&quot;user_prefs&quot;, MODE_PRIVATE)&#10;        val userId = prefs.getLong(&quot;user_id&quot;, -1L)&#10;        if (userId == -1L) {&#10;            Toast.makeText(this, &quot;Usuário não encontrado.&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Buscar decks do usuário de forma assíncrona&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            val result = withContext(Dispatchers.IO) { deckRepository.getDecksByUser(userId) }&#10;            if (result.isSuccess) {&#10;                val decks: List&lt;ReturnDeckDto&gt; = result.getOrNull() ?: emptyList&lt;ReturnDeckDto&gt;()&#10;                val deckMap = decks.associateBy { it.name } // Mapear nome para id&#10;                if (decks.isEmpty()) {&#10;                    // Exibe mensagem se não houver decks&#10;                    val emptyText = TextView(this@StudyRoomActivity).apply {&#10;                        text = &quot;Nenhum deck encontrado.&quot;&#10;                        setTextColor(resources.getColor(android.R.color.white, null))&#10;                        textSize = 16f&#10;                        gravity = android.view.Gravity.CENTER&#10;                    }&#10;                    llTop.addView(emptyText)&#10;                } else {&#10;                    // Para cada deck, cria um bloco arrastável&#10;                    for ((index, deck) in decks.withIndex()) {&#10;                        val frameLayout = FrameLayout(this@StudyRoomActivity).apply {&#10;                            layoutParams = LinearLayout.LayoutParams(dp(180), dp(60)).apply {&#10;                                marginEnd = dp(8)&#10;                                topMargin = dp(6)&#10;                            }&#10;                            // Imagem de fundo do bloco&#10;                            setBackgroundResource(R.drawable.sample2)&#10;                        }&#10;                        val textView = TextView(this@StudyRoomActivity).apply {&#10;                            layoutParams = FrameLayout.LayoutParams(&#10;                                FrameLayout.LayoutParams.MATCH_PARENT,&#10;                                FrameLayout.LayoutParams.MATCH_PARENT&#10;                            )&#10;                            text = deck.name&#10;                            setTextColor(resources.getColor(android.R.color.black, null))&#10;                            gravity = android.view.Gravity.CENTER&#10;                        }&#10;                        frameLayout.addView(textView)&#10;                        // Evento de toque longo para iniciar o arraste do deck&#10;                        frameLayout.setOnLongClickListener { v -&gt;&#10;                            val item = ClipData.Item(deck.name)&#10;                            val dragData = ClipData(&#10;                                deck.name,&#10;                                arrayOf(ClipDescription.MIMETYPE_TEXT_PLAIN),&#10;                                item&#10;                            )&#10;                            val shadow = View.DragShadowBuilder(v)&#10;                            v.visibility = View.INVISIBLE&#10;                            v.startDragAndDrop(dragData, shadow, v, 0)&#10;                            true&#10;                        }&#10;                        // Evento de clique simples para abrir a tela do deck&#10;                        frameLayout.setOnClickListener {&#10;                            val intent =&#10;                                Intent(this@StudyRoomActivity, DeckScreenActivity::class.java)&#10;                            intent.putExtra(&quot;deckId&quot;, deck.idDeck)&#10;                            intent.putExtra(&quot;deckName&quot;, deck.name)&#10;                            startActivity(intent)&#10;                            overridePendingTransition(0, 0)&#10;                        }&#10;                        // Guardar o id do deck no tag do frameLayout para uso no drop&#10;                        frameLayout.tag = deck.idDeck&#10;                        llTop.addView(frameLayout)&#10;                    }&#10;                }&#10;            } else {&#10;                // Exibe mensagem de erro se falhar ao buscar decks&#10;                val errorText = TextView(this@StudyRoomActivity).apply {&#10;                    text = &quot;Erro ao carregar decks.&quot;&#10;                    setTextColor(resources.getColor(android.R.color.white, null))&#10;                    textSize = 16f&#10;                    gravity = android.view.Gravity.CENTER&#10;                }&#10;                llTop.addView(errorText)&#10;            }&#10;&#10;&#10;            // Botões e overlays&#10;            val btnReturnToHome = findViewById&lt;Button&gt;(R.id.btnReturnToHome)&#10;            val btnLeftCenter = findViewById&lt;ImageButton&gt;(R.id.btnLeftCenter)&#10;            val btnRightCenter = findViewById&lt;Button&gt;(R.id.btnRightCenter)&#10;            val leftOverlay = findViewById&lt;FrameLayout&gt;(R.id.leftOverlay)&#10;            val btnCloseOverlay = findViewById&lt;ImageButton&gt;(R.id.btnCloseOverlay)&#10;&#10;&#10;            // Eventos de clique dos botões&#10;            btnLeftCenter.setOnClickListener {&#10;                leftOverlay.visibility = View.VISIBLE&#10;                btnReturnToHome.visibility = View.INVISIBLE&#10;                btnLeftCenter.visibility = View.INVISIBLE&#10;            }&#10;&#10;            btnRightCenter.setOnClickListener {&#10;                val intent = Intent(this@StudyRoomActivity, FlashcardActivity::class.java)&#10;                if (selectedDeckId == null) {&#10;                    Toast.makeText(&#10;                        this@StudyRoomActivity,&#10;                        &quot;Por favor, arraste um deck para o caldeirão antes de começar a estudar!&quot;,&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    try {&#10;                        val result = withContext(Dispatchers.IO) {&#10;                            userCardRepository.practiceCardsByDeck(userId, selectedDeckId!!)&#10;                        }&#10;&#10;                        if (result.isSuccess) {&#10;                            val cards = result.getOrNull().orEmpty()&#10;                            if (cards.isEmpty()) {&#10;                                Toast.makeText(&#10;                                    this@StudyRoomActivity,&#10;                                    &quot;Deck selecionado não possui cards.&quot;,&#10;                                    Toast.LENGTH_LONG&#10;                                ).show()&#10;                                return@launch&#10;                            }&#10;&#10;                        } else {&#10;                            Toast.makeText(&#10;                                this@StudyRoomActivity,&#10;                                &quot;Erro ao verificar cards do deck.&quot;,&#10;                                Toast.LENGTH_LONG&#10;                            ).show()&#10;                        }&#10;&#10;&#10;                    } catch (e: Exception) {&#10;                        Toast.makeText(&#10;                            this@StudyRoomActivity,&#10;                            &quot;Erro de conexão: ${e.message}&quot;,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;&#10;&#10;&#10;                intent.putExtra(&quot;deckId&quot;, selectedDeckId)&#10;                startActivity(intent)&#10;//                overridePendingTransition(0, 0)&#10;//                finish()&#10;            }&#10;&#10;            btnCloseOverlay.setOnClickListener {&#10;                leftOverlay.visibility = View.GONE&#10;                btnReturnToHome.visibility = View.VISIBLE&#10;                btnLeftCenter.visibility = View.VISIBLE&#10;            }&#10;&#10;            btnReturnToHome.setOnClickListener {&#10;                startActivity(Intent(this@StudyRoomActivity, HomeActivity::class.java)) // Inicia a MainActivity&#10;                overridePendingTransition(0, 0)&#10;                finish() // Finaliza a atividade atual e retorna para a anterior (MainActivity)&#10;            }&#10;&#10;            // Botão de teste para abrir CreateDeckActivity&#10;            val btnOpenCreateDeck = findViewById&lt;Button&gt;(R.id.btnOpenCreateDeck)&#10;            btnOpenCreateDeck.setOnClickListener {&#10;                CreateDeckDialogFragment().show(supportFragmentManager, &quot;CreateDeckDialog&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>